{
  "version": 3,
  "sources": ["monkeyPatches.ts", "worker.ts"],
  "sourcesContent": ["export var initArrayWrappedForEach = (\n  widthNum: number,\n  cellWidth: number,\n  heightNum: number,\n  cellHeight: number,\n): typeof Uint8Array.prototype.wrappedForEach => {\n  return function wrappedForEach(callback) {\n    for (\n      var i = 0, j = 0, rowOffset = 0;\n      i < widthNum && j < heightNum;\n      i + 1 === widthNum\n        ? (i = 0, j++, rowOffset += widthNum)\n        : i++\n    ) {\n      callback({\n        cells: this,\n        currentIndex: i + rowOffset,\n        i,\n        j,\n        widthNum,\n        heightNum,\n        cellWidth,\n        cellHeight,\n      });\n    }\n  };\n};\n\nexport var shuffle = (array) => {\n  var result = [...array];\n  var i = array.length;\n  while(i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n};", "import { initArrayWrappedForEach, shuffle } from \"./monkeyPatches\";\n\n/**\n * Before\n */\nvar canvas = null;\nvar context = null;\nvar helperCanvas = null;\nvar helperImageData = null;\nvar helperContext = null;\n\n/**\n * Cells\n */\nvar mask = {\n  empty: 0b0,\n  alive: 0b10000,\n  dead: 0b01111,\n  aliveNext: 0b01000,\n  deadNext: 0b10111,\n  n: 0b00111,\n  dropN: 0b11000,\n};\n\nvar currentResolution = 0;\n// var palette = shuffle([\n//   \"#f0ba00\",\n//   \"#de8790\",\n//   \"#6b1f1c\",\n//   \"#333c7d\",\n//   \"#367148\",\n//   \"#91b9d6\",\n//   \"#aa2404\",\n// ]).slice(0, 3);\n\nvar palette = shuffle([\n  new Uint8Array([255, 0, 0, 255]),\n  new Uint8Array([0, 255, 0, 255]),\n  new Uint8Array([0, 0, 255, 255]),\n  new Uint8Array([255, 255, 0, 255]),\n  new Uint8Array([0, 255, 255, 255]),\n  new Uint8Array([255, 0, 255, 255]),\n]);\n\n// context.putImageData(\n//       new ImageData(\n//         new Uint8ClampedArray(\n//           imageArray,\n//         ),\n//         canvasWidth,\n//         canvasWidth\n//       ), 0, 0\n//     );\n\n// for (var offsetW = 0; offsetW < cellWidth; offsetW++) {\n//     for (var offsetH = 0; offsetH < cellWidth; offsetH++) {\n//       var indices = getColorIndicesByCoordinates(\n//         Math.floor(i * cellWidth) + offsetW,\n//         Math.floor(j * cellWidth) + offsetH,\n//         canvasWidth\n//       );\n\n//       if (current & mask.alive) {\n//         var currentColor = palette[current & mask.n];\n//         imageArray[indices[0]] = currentColor[0]; // 0 * 4 = 0\n//         imageArray[indices[1]] = currentColor[1]; // 0 * 4 + 1 = 1\n//         imageArray[indices[2]] = currentColor[2]; // 0 * 4 + 2 = 2\n//         imageArray[indices[3]] = currentColor[3]; // 0 * 4 + 3 = 3\n//       } else {\n//         imageArray[indices[0]] = 0;\n//         imageArray[indices[1]] = 0;\n//         imageArray[indices[2]] = 0;\n//         imageArray[indices[3]] = 0;\n//       }\n\n/**\n * Render\n */\nvar clock = Date.now();\nvar fps = 4;\nvar frameDuration = 1000 / fps;\nvar currentRafId = 0;\n\nvar updateResolution = (canvasWidth, canvasHeight, resolution) => {\n  currentResolution = Number(resolution);\n\n  var widthNum = currentResolution;\n  var heightNum = currentResolution;\n\n  var cellWidth = canvasWidth / widthNum;\n  var cellHeight = canvasHeight / heightNum;\n\n  var sideDivider = currentResolution / canvasWidth;\n\n  return {\n    widthNum,\n    cellWidth,\n    heightNum,\n    cellHeight,\n    sideDivider,\n  };\n};\n\nvar getColorIndicesByCoordinates = (i, j, imageNaturalWidth) => {\n  var red = j * (imageNaturalWidth * 4) + i * 4;\n  return [red, red + 1, red + 2, red + 3];\n};\n\nvar generateCells = (rgbArray, widthNum, canvasWidth, heightNum, _, sideDivider) => {\n  var i = 0;\n  var j = 0;\n\n  var cells = new Uint8Array(\n    Array.from(\n      { length: widthNum * heightNum },\n      () => {\n        i + 1 === widthNum\n          ? (i = 0, j++)\n          : i++;\n\n        return rgbArray[getColorIndicesByCoordinates(\n          Math.floor(i / sideDivider),\n          Math.floor(j / sideDivider),\n          canvasWidth,\n        )[0]] < 129\n          ? mask.alive\n          : mask.empty;\n      }\n    )\n  );\n\n  return cells;\n};\n\nvar isCellAliveInNextGenerationCallback = ({\n  cells,\n  currentIndex,\n  i,\n  j,\n  widthNum,\n  heightNum,\n}) => {\n  var current = cells[currentIndex];\n\n  var n = 0;\n\n  ((i - 1) > 0\n      && cells[currentIndex - 1] & mask.alive)\n      && n++;\n\n  ((i + 1) < widthNum\n      && cells[currentIndex + 1] & mask.alive)\n      && n++;\n\n  ((j - 1) > 0\n      && cells[currentIndex - widthNum] & mask.alive)\n      && n++;\n\n  ((j + 1) < heightNum\n      && cells[currentIndex + widthNum] & mask.alive)\n      && n++;\n\n  cells[currentIndex] = (\n    (n === 1 || n === 3)\n      ? current | mask.aliveNext\n      : current & mask.deadNext\n  ) | n;\n};\n\nvar drawCellsCallback = ({\n  currentIndex,\n  cells,\n  cellWidth,\n  cellHeight,\n  i,\n  j,\n}) => {\n  var current = cells[currentIndex];\n\n  // current & mask.alive\n  // && (\n  //   context.fillStyle = palette[(current & mask.n) - 1],\n  //   context.fillRect(\n  //     i * cellWidth,\n  //     j * cellHeight,\n  //     cellWidth,\n  //     cellHeight\n  //   )\n  // );\n\n  const red = currentIndex * 4;\n  if (current & mask.alive) {\n    var currentColor = palette[current & mask.n];\n    helperImageData.data[red] = currentColor[0]; // 0 * 4 = 0\n    helperImageData.data[red + 1] = currentColor[1]; // 0 * 4 + 1 = 1\n    helperImageData.data[red + 2] = currentColor[2]; // 0 * 4 + 2 = 2\n    helperImageData.data[red + 3] = currentColor[3]; // 0 * 4 + 3 = 3\n  } else {\n    helperImageData.data[red] = 0;\n    helperImageData.data[red + 1] = 0;\n    helperImageData.data[red + 2] = 0;\n    helperImageData.data[red + 3] = 0;\n  }\n\n  cells[currentIndex] =\n    (current & mask.aliveNext)\n      ? (current | mask.alive) & mask.dropN\n      : mask.empty;\n};\n\nvar tick = (cells, canvasWidth, canvasHeight) => {\n  var currentTime = Date.now();\n\n  if (currentTime - clock >= frameDuration) {\n    cells.wrappedForEach(isCellAliveInNextGenerationCallback);\n    cells.wrappedForEach(drawCellsCallback);\n\n    helperContext.putImageData(helperImageData, 0, 0);\n    context.drawImage(helperCanvas, 0, 0, canvasWidth, canvasHeight);\n    clock = currentTime;\n  }\n\n  currentRafId = requestAnimationFrame(\n    tick.bind(\n      null,\n      cells,\n      canvasWidth,\n      canvasHeight\n    ));\n};\n\nvar resizeCanvas = (canvas, width, height) => {\n  canvas.width = width;\n  canvas.height = height;\n};\n\nvar processFirstFrame = (image, canvasWidth, canvasHeight, resolution) => {\n  currentRafId > 0 && cancelAnimationFrame(currentRafId);\n\n  resizeCanvas(canvas, canvasWidth, canvasHeight);\n\n  var {\n    widthNum,\n    cellWidth,\n    heightNum,\n    cellHeight,\n    sideDivider,\n  } = updateResolution(canvasWidth, canvasHeight, resolution);\n\n  var imageMaxSide = Math.max(image.width, image.height);\n  var imageRatio = canvasWidth / imageMaxSide;\n  var scaledWidth = image.width * imageRatio;\n  var scaledHeight = image.height * imageRatio;\n  var dx = (canvasWidth - scaledWidth) / 2;\n  var dy = (canvasHeight - scaledHeight) / 2;\n\n  context.drawImage(image, dx, dy, image.width * imageRatio, image.height * imageRatio);\n\n  var rgbArray = context.getImageData(0, 0, canvasWidth, canvasHeight).data;\n  context.clearRect(0, 0, canvasWidth, canvasHeight);\n  context.fillStyle = \"#f00\";\n\n  var wrappedForEach = initArrayWrappedForEach(widthNum, cellWidth, heightNum, cellHeight);\n  var cells = generateCells(rgbArray, widthNum, canvasWidth, heightNum, canvasHeight, sideDivider);\n\n  helperCanvas = new OffscreenCanvas(widthNum, heightNum);\n  helperContext = helperCanvas.getContext(\"2d\");\n  helperImageData = new ImageData(widthNum, heightNum);\n\n  Uint8Array.prototype.wrappedForEach = wrappedForEach;\n  tick(cells, canvasWidth, canvasHeight);\n};\n\naddEventListener(\"message\", (event) => {\n  var {\n    canvas: transferredCanvas,\n    image,\n    canvasWidth,\n    canvasHeight,\n    resolution\n  } = event.data;\n\n  switch (event.data.message) {\n  case \"initCanvas\":\n    canvas = transferredCanvas;\n    context = canvas.getContext(\"2d\");\n    context.imageSmoothingEnabled = false;\n    break;\n  case \"processFirstFrame\":\n    processFirstFrame(\n      image,\n      canvasWidth,\n      canvasHeight,\n      resolution\n    );\n    break;\n  }\n});\n"],
  "mappings": "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",
  "names": ["initArrayWrappedForEach", "widthNum", "cellWidth", "heightNum", "cellHeight", "callback", "i", "j", "rowOffset", "shuffle", "array", "result", "canvas", "context", "helperCanvas", "helperImageData", "helperContext", "mask", "currentResolution", "palette", "shuffle", "clock", "fps", "frameDuration", "currentRafId", "updateResolution", "canvasWidth", "canvasHeight", "resolution", "widthNum", "heightNum", "cellWidth", "cellHeight", "sideDivider", "getColorIndicesByCoordinates", "i", "j", "imageNaturalWidth", "red", "generateCells", "rgbArray", "_", "cells", "isCellAliveInNextGenerationCallback", "currentIndex", "current", "n", "drawCellsCallback", "currentColor", "tick", "currentTime", "resizeCanvas", "width", "height", "processFirstFrame", "image", "imageMaxSide", "imageRatio", "scaledWidth", "scaledHeight", "dx", "dy", "wrappedForEach", "initArrayWrappedForEach", "event", "transferredCanvas"]
}
