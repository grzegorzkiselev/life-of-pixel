{
  "version": 3,
  "sources": ["monkeyPatches.ts", "worker.ts"],
  "sourcesContent": ["export var initArrayWrappedForEach = (\n  widthNum: number,\n  cellWidth: number,\n  heightNum: number,\n  cellHeight: number,\n): typeof Uint8Array.prototype.wrappedForEach => {\n  return function wrappedForEach(callback) {\n    for (\n      var i = 0, j = 0, rowOffset = 0;\n      i < widthNum && j < heightNum;\n      i + 1 === widthNum\n        ? (i = 0, j++, rowOffset += widthNum)\n        : i++\n    ) {\n      callback({\n        cells: this,\n        currentIndex: i + rowOffset,\n        i,\n        j,\n        widthNum,\n        heightNum,\n        cellWidth,\n        cellHeight,\n      });\n    }\n  };\n};\n\nexport var shuffle = (array) => {\n  var result = [...array];\n  var i = array.length;\n  while(i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n};", "import { initArrayWrappedForEach, shuffle } from \"./monkeyPatches\";\n\n/**\n * Before\n */\nvar canvas = null;\nvar context = null;\n\n/**\n * Cells\n */\nvar mask = {\n  empty: 0b0,\n  alive: 0b10000,\n  dead: 0b01111,\n  aliveNext: 0b01000,\n  deadNext: 0b10111,\n  n: 0b00111,\n  dropN: 0b11000,\n};\n\nvar currentResolution = 0;\nvar palette = shuffle([\n  \"#f0ba00\",\n  \"#de8790\",\n  \"#6b1f1c\",\n  \"#333c7d\",\n  \"#367148\",\n  \"#91b9d6\",\n  \"#aa2404\",\n]).slice(0, 3);\n\n/**\n * Render\n */\nvar clock = Date.now();\nvar fps = 4;\nvar frameDuration = 1000 / fps;\nvar currentRafId = 0;\n\nvar updateResolution = (canvasWidth, canvasHeight, resolution) => {\n  currentResolution = Number(resolution);\n\n  var widthNum = currentResolution;\n  var heightNum = currentResolution;\n\n  var cellWidth = canvasWidth / widthNum;\n  var cellHeight = canvasHeight / heightNum;\n\n  var sideDivider = currentResolution / canvasWidth;\n\n  return {\n    widthNum,\n    cellWidth,\n    heightNum,\n    cellHeight,\n    sideDivider,\n  };\n};\n\nvar getColorIndicesByCoordinates = (i, j, imageNaturalWidth) => {\n  var red = j * (imageNaturalWidth * 4) + i * 4;\n  return [red, red + 1, red + 2, red + 3];\n};\n\nvar generateCells = (rgbArray, widthNum, canvasWidth, heightNum, _, sideDivider) => {\n  var i = 0;\n  var j = 0;\n\n  var cells = new Uint8Array(\n    Array.from(\n      { length: widthNum * heightNum },\n      () => {\n        i + 1 === widthNum\n          ? (i = 0, j++)\n          : i++;\n\n        return rgbArray[getColorIndicesByCoordinates(\n          Math.floor(i / sideDivider),\n          Math.floor(j / sideDivider),\n          canvasWidth,\n        )[0]] < 129\n          ? mask.alive\n          : mask.empty;\n      }\n    )\n  );\n\n  return cells;\n};\n\nvar isCellAliveInNextGenerationCallback = ({\n  cells,\n  currentIndex,\n  i,\n  j,\n  widthNum,\n  heightNum,\n}) => {\n  var current = cells[currentIndex];\n\n  var n = 0;\n\n  ((i - 1) > 0\n      && cells[currentIndex - 1] & mask.alive)\n      && n++;\n\n  ((i + 1) < widthNum\n      && cells[currentIndex + 1] & mask.alive)\n      && n++;\n\n  ((j - 1) > 0\n      && cells[currentIndex - widthNum] & mask.alive)\n      && n++;\n\n  ((j + 1) < heightNum\n      && cells[currentIndex + widthNum] & mask.alive)\n      && n++;\n\n  cells[currentIndex] = (\n    (n === 1 || n === 3)\n      ? current | mask.aliveNext\n      : current & mask.deadNext\n  ) | n;\n};\n\nvar drawCellsCallback = ({\n  currentIndex,\n  cells,\n  cellWidth,\n  cellHeight,\n  i,\n  j,\n}) => {\n  var current = cells[currentIndex];\n\n  current & mask.alive\n  && (\n    context.fillStyle = palette[(current & mask.n) - 1],\n    context.fillRect(\n      i * cellWidth,\n      j * cellHeight,\n      cellWidth,\n      cellHeight\n    )\n  );\n\n  cells[currentIndex] =\n    (current & mask.aliveNext)\n      ? (current | mask.alive) & mask.dropN\n      : mask.empty;\n};\n\nvar tick = (cells, canvasWidth, canvasHeight) => {\n  var currentTime = Date.now();\n\n  if (currentTime - clock >= frameDuration) {\n    cells.wrappedForEach(isCellAliveInNextGenerationCallback);\n    context.clearRect(0, 0, canvasWidth, canvasHeight);\n    cells.wrappedForEach(drawCellsCallback);\n    clock = currentTime;\n  }\n\n  currentRafId = requestAnimationFrame(\n    tick.bind(\n      null,\n      cells,\n      canvasWidth,\n      canvasHeight\n    ));\n};\n\nvar resizeCanvas = (canvas, width, height) => {\n  canvas.width = width;\n  canvas.height = height;\n};\n\nvar processFirstFrame = (image, canvasWidth, canvasHeight, resolution) => {\n  currentRafId > 0 && cancelAnimationFrame(currentRafId);\n\n  resizeCanvas(canvas, canvasWidth, canvasHeight);\n\n  var {\n    widthNum,\n    cellWidth,\n    heightNum,\n    cellHeight,\n    sideDivider,\n  } = updateResolution(canvasWidth, canvasHeight, resolution);\n\n  var imageMaxSide = Math.max(image.width, image.height);\n  var imageRatio = canvasWidth / imageMaxSide;\n  var scaledWidth = image.width * imageRatio;\n  var scaledHeight = image.height * imageRatio;\n  var dx = (canvasWidth - scaledWidth) / 2;\n  var dy = (canvasHeight - scaledHeight) / 2;\n\n  context.drawImage(image, dx, dy, image.width * imageRatio, image.height * imageRatio);\n\n  var rgbArray = context.getImageData(0, 0, canvasWidth, canvasHeight).data;\n  context.clearRect(0, 0, canvasWidth, canvasHeight);\n  context.fillStyle = \"#f00\";\n\n  var wrappedForEach = initArrayWrappedForEach(widthNum, cellWidth, heightNum, cellHeight);\n  var cells = generateCells(rgbArray, widthNum, canvasWidth, heightNum, canvasHeight, sideDivider);\n\n  Uint8Array.prototype.wrappedForEach = wrappedForEach;\n  tick(cells, canvasWidth, canvasHeight);\n};\n\naddEventListener(\"message\", (event) => {\n  var {\n    canvas: transferredCanvas,\n    image,\n    canvasWidth,\n    canvasHeight,\n    resolution\n  } = event.data;\n\n  switch (event.data.message) {\n  case \"initCanvas\":\n    canvas = transferredCanvas;\n    context = canvas.getContext(\"2d\");\n    break;\n  case \"processFirstFrame\":\n    processFirstFrame(\n      image,\n      canvasWidth,\n      canvasHeight,\n      resolution\n    );\n    break;\n  }\n});"],
  "mappings": "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",
  "names": ["initArrayWrappedForEach", "widthNum", "cellWidth", "heightNum", "cellHeight", "callback", "i", "j", "rowOffset", "shuffle", "array", "result", "canvas", "context", "mask", "currentResolution", "palette", "shuffle", "clock", "fps", "frameDuration", "currentRafId", "updateResolution", "canvasWidth", "canvasHeight", "resolution", "widthNum", "heightNum", "cellWidth", "cellHeight", "sideDivider", "getColorIndicesByCoordinates", "i", "j", "imageNaturalWidth", "red", "generateCells", "rgbArray", "_", "cells", "isCellAliveInNextGenerationCallback", "currentIndex", "current", "n", "drawCellsCallback", "tick", "currentTime", "resizeCanvas", "width", "height", "processFirstFrame", "image", "imageMaxSide", "imageRatio", "scaledWidth", "scaledHeight", "dx", "dy", "wrappedForEach", "initArrayWrappedForEach", "event", "transferredCanvas"]
}
